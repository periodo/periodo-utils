"use strict";

var peg = require('pegjs'),
    grammar = '// vim: set filetype=javascript\n\n{\n  var bpBase = parseInt(options.bpBase || 1950);\n\n  // Format a number to be ISO8601 compatible\n  function zeroPadded(number) {\n    var numberInt = parseInt(number)\n      , numberStr = \'\' + Math.abs(numberInt)\n      , sign = numberInt < 0 ? \'-\' : \'\'\n\n    if (numberStr.length < 4) numberStr = (\'0000\' + numberStr).substr(-4, 4);\n\n    return sign + numberStr;\n  }\n\n  function formatYear(type, value, label) {\n    var ret = {\n      _type: type,\n      \'in\': { year: zeroPadded(value) }\n    }\n    if (label) ret.label = label;\n    return ret;\n  }\n\n  function ADtoISO (year) { return parseInt(year) }\n  function BCtoISO (year) { return -parseInt(year) + 1 }\n\n  function formatRange(beginning, end) {\n    var ret = { \'in\': {} };\n    if (beginning !== null) ret[\'in\'].earliestYear = zeroPadded(beginning);\n    if (end !== null) ret[\'in\'].latestYear = zeroPadded(end);\n    return ret;\n  }\n\n\n  // Create a range based on a century/millennium designation\n  function makeEpoch(base, val, neg, modifier) {\n    var adjust = Math.floor(base / 3)\n      , earlyAdjust = adjust * (modifier ? modifier - 1 : 0)\n      , lateAdjust = adjust * (modifier ? 3 - modifier : 0)\n      , range\n      , ret\n\n    val = parseInt(val, 10) * base;\n\n    range = neg ?\n      [-val + 1 + earlyAdjust, -val + base - lateAdjust] :\n      [val - (base - 1) + earlyAdjust, val - lateAdjust];\n\n    ret = formatRange(range[0], range[1]);\n    ret._type = \'gregorian\';\n\n    return ret;\n  }\n}\n\nstart = unclear? SPACE* ret:formats SPACE* {\n  ret.label = text();\n  return ret\n}\n\nformats = present / range / singleyear\n\npresent = \'present\'i { return {label: \'present\', _type: \'present\'} };\n\n// The formats that we accept\nsingleyear = \n  gregorianyear\n  / bpyear\n  / iso8601year\n\nrange =\n  century\n  / millennium\n  / slashSeparatedRange\n\n// Unclear prefixes\nunclear =\n  \'~\'\n  / \'around\'\n  / \'circa\'\n  / \'about\'\n  / \'approximately\'\n  / \'ca.\'i\n  / \'ca\'i\n  / \'c.\'i !\'e\'i\n  / \'c\'i !(\'.e\'i / \'e\'i)\n\nslashSeparatedRange = \n  year1:digitsorquestionmark \'/\' year2:digitsorquestionmark SPACE* suffix:(bc / ad)\n    {\n      var fn = suffix.neg ? BCtoISO : ADtoISO\n        , ret = formatRange(fn(year1), fn(year2))\n\n      ret._type = \'gregorian\';\n      return ret;\n    }\n  / year1:simpleyear \'/\' year2:simpleyear\n    {\n      var ret = formatRange(year1, year2);\n      ret._type = \'iso8601\';\n      return ret;\n    }\n\nsimpleyear = sign:sign? digits:digitsorquestionmark { return (sign || \'\') + digits.join(\'\') }\n\niso8601year = year:simpleyear { return formatYear(\'iso8601\', year) }\n\ngregorianyear =\n  val:(\n      year:digitsorquestionmark \' \'* suffix:(bc / ad) { return { label: year, neg: suffix.neg } }\n      / prefix:(bc / ad) \' \'* year:digitsorquestionmark { return { label: year, neg: prefix.neg } }\n  )\n  {\n    var year = val.neg ? BCtoISO(val.label) : ADtoISO(val.label);\n    return formatYear(\'gregorian\', year)\n  }\n\nbpyear =\n  year:digitsorcomma SPACE* suffix:(bp)\n  {\n    var year = suffix.base - parseInt(year, 10);\n    return formatYear(\'bp\' + suffix.base, year, text());\n  }\n\n// Century / millennium stuff\nearly = (\'early\'i / \'beginning of the\'i / \'beginning of\'i / \'start of the\'i) { return 1 }\nmiddle = (\'middle of the\'i / \'mid\'i) { return 2 }\nlate = (\'late\'i / \'end of the\'i) { return 3 }\n\nmodifier = early / middle / late\n\ncentury = modifier:modifier? SPACE* value:ordinal SPACE+ (\'century\'i / \'cent.\' / \'cent\') SPACE* suffix:(bc / ad)?\n  { return makeEpoch(100, value, suffix ? suffix.neg : false, modifier) }\n\n\nmillennium = modifier:modifier? SPACE* value:ordinal SPACE+ \'millennium\'i SPACE* suffix:(bc /ad)?\n  { return makeEpoch(1000, value, suffix ? suffix.neg : false, modifier) }\n\n\n// Constants\nsign = \'+\' / \'-\'\ndigit = [0-9]\nSPACE = \' \'\n\ndigitsorcomma = \n  head:(onetothreedigits) tail:(\',\' ds:threedigits { return ds })+ { return head + tail.join(\'\') }\n  / manydigits\n\ndigitsorquestionmark = digitsorcomma \'?\'?\n\n//head:digitsorcomma tail:(\'?\')? { return { value: head + (tail || \'\'), approximate: !!tail } }\n\nonetothreedigits = a:digit b:digit? c:digit? { return a + (b || \'\') + (c || \'\')}\nthreedigits = a:digit b:digit c:digit { return a + b + c }\nfourdigits = a:digit b:digit c:digit d:digit { return a + b + c + d }\nmanydigits = digits:digit+ { return digits.join(\'\') }\n\nbp = \'c14 \'i? \'b\'i \'.\'? \'p\'i \'.\'? base:(SPACE* digit+)? {\n  return {\n    label: text(),\n    base: base ? parseInt(base[1].join(\'\').trim(), 10) : bpBase\n  }\n}\nbc = label:(\'b\'i \'.\'? \'c\'i \'.\'? e:(E:\'e\'i D:\'.\'? { return E + (D||\'\') })?) { return {label: label.join(\'\'), neg: true} }\nad = label:(\'a\'i \'.\'? \'d\'i \'.\'? / \'c\'i \'.\'? \'e\'i \'.\'?) { return {label: label.join(\'\'), neg: false} }\n\n\n// ORDINAL NUMBERS\nnumericOrdinal = teenordinal / nonteenordinal\n\nnumFollowedByNum = val:digit &digit { return val }\nordinalhead = nums:numFollowedByNum* { return nums.join(\'\') }\nordinaltail =\n  val:([1]) suffix:\'st\'\n  / val:([2]) suffix:\'nd\'\n  / val:([3]) suffix:\'rd\'\n  / val:([4567890]) suffix: \'th\'\n\nnumFollowedByTwoNums = val:digit &(digit digit) { return val }\nteenOrdinalHead = nums:numFollowedByTwoNums* { return nums.join(\'\') }\nteenOrdinalTail = val:(\'1\' digit) \'th\' { return val }\n\nteenordinal = head:teenOrdinalHead tail:teenOrdinalTail { return parseInt(head + tail.join(\'\'), 10) }\nnonteenordinal = head:ordinalhead tail:ordinaltail { return parseInt(head + tail.join(\'\'), 10) }\n\n\n// Natural language ordinals\nenglishOrdinal =\n  englishOrdinalAlone\n  / head:englishOrdinalHead? mid:\'-\'? tail:englishOrdinalTail { return parseInt((head || 0) + tail, 10) }\n\nenglishOrdinalHead =\n  \'twenty\'i { return 20 }\n  / \'thirty\'i { return 30 }\n  / \'forty\'i { return  40 }\n  / \'fifty\'i { return  50 }\n  / \'sixty\'i { return  60 }\n  / \'seventy\'i { return  70 }\n  / \'eighty\'i { return  80 }\n  / \'ninety\'i { return  90 }\n\nenglishOrdinalTail =\n  \'first\'i { return  1 }\n  / \'second\'i { return  2 }\n  / \'third\'i { return  3 }\n  / \'fourth\'i { return  4 }\n  / \'fifth\'i { return  5 }\n  / \'sixth\'i { return  6 }\n  / \'seventh\'i { return  7 }\n  / \'eighth\'i { return  8 }\n  / \'ninth\'i { return  9 }\n\nenglishOrdinalAlone =\n  \'tenth\'i { return  10 }\n  / \'eleventh\'i { return  11 }\n  / \'twelfth\'i { return  12 }\n  / \'thirteenth\'i { return  13 }\n  / \'fourteenth\'i { return  14 }\n  / \'fifteenth\'i { return  15 }\n  / \'sixteenth\'i { return  16 }\n  / \'seventeenth\'i { return  17 }\n  / \'eighteenth\'i { return  18 }\n  / \'nineteenth\'i { return  19 }\n  / \'twentieth\'i { return  20 }\n  / \'thirtieth\'i { return  30 }\n  / \'fortieth\'i { return  40 }\n  / \'fiftieth\'i { return  50 }\n  / \'sixtieth\'i { return  60 }\n  / \'seventieth\'i { return  70 }\n  / \'eightieth\'i { return  80 }\n  / \'ninetieth\'i { return  90 }\n\nordinal = englishOrdinal / numericOrdinal\n',
    options = { allowedStartRules: ['start', 'gregorianyear', 'bpyear', 'iso8601year'] },
    parser = peg.buildParser(grammar, options);

function parse(input, opts) {
  opts = opts || {};

  if (opts.throw) return parser.parse(input, opts);

  try {
    return parser.parse(input, opts);
  } catch (e) {
    return null;
  }
}

parse._parser = parser;

module.exports = parse;